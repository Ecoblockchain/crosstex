#! /usr/bin/env python
#
# CROSSTEX: This is a new, object-oriented cross-referencing engine, to
#         replace BIBTEX.
#
# (c) August 2006, Emin Gun Sirer
# Distributed under the GNU Public License, v2
# See the file COPYING for copyright info
#
#         Features:
#         Object-oriented: Need only enter conference, workshop, venue, etc
#            information once, no need to reenter everything under every descriptor
#            as is required in the relational bibtex model
#         Can generate short or long form references: Suitable for the space crunch as well
#            as formal, long-form references.
#         Capitalization works: Things get capitalized the way they appear in the references.
#         Include files: A bibliography can be broken up into modular units.
#         Sanity checking: Running crosstex on a bib/xtx file will check all entries for conformance.
#         Supports entries with multiple keys, e.g. @book{x=y=z, author=...}
#         Backwards compatible with bibtex
#         Can generate bibtex output: if you must use a bibtex style file, you can
#
import sys
topdir = "/usr/share/texmf/crosstex"
sys.path.append(topdir)

import ply.lex as lex
import ply.yacc as yacc

import copy
import math
import pipes
import re
import optparse
import string
import tempfile

import crosstexobjects


# Pre-defined styles.

styles = {
    'abbrv': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--short', 'author', '--cite-by', 'initials'],
    'alpha': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--cite-by', 'initials'],
    'full': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--cite-by', 'fullname', '--add-proceedings', '--add-in'],
    'unsrt': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--cite-by', 'number', '--no-sort'],
    'plain': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--cite-by', 'number'],
    'html': ['-l', 'Abstract', '-l', 'URL', '-l', 'PS', '-l', 'PDF', '-l', 'HTML', '-l', 'DVI', '-l', 'TeX', '-l', 'Bib', '-l', 'FTP', '-l', 'HTTP', '-l', 'RTF', '--break-lines', '--blank-labels', '--title-head', '--abstract', '--keywords'],
}


# Set up options.

optparser = optparse.OptionParser(usage="usage: %prog [options] files", version="CrossTeX 0.1", description="A modern, object-oriented bibliographic tool intended to replace BibTeX.")

def optstyle(option, opt, value, parser):
    global styles
    for i in range(len(styles[value])):
        parser.rargs.insert(i, styles[value][i])

def optheading(option, opt, value, parser, reversed=False):
    parser.values.heading = (reversed, value)

def optsort(option, opt, value, parser, reversed=False):
    if parser.values.sort == None or value == 'none':
	parser.values.sort = []
    parser.values.sort.append((reversed, value))

def optconvert(option, opt, value, parser):
    global styles
    parser.values.convert = opt[6:]
    if opt[6:] in styles:
        for i in range(len(styles[opt[6:]])):
            parser.rargs.insert(i, styles[opt[6:]][i])

optparser.add_option('-d', '--dir', type='string', action='append', help="Add a directory in which to find data files, searched from last specified to first. Default: %default")
optparser.add_option('--quiet', action='store_const', const=0, dest='check', help="Do not sanity check the input.")
optparser.add_option('--strict', action='store_const', const=2, dest='check', help="Apply stricter checks.")
optparser.add_option('--dump', metavar='TYPE', type='choice', choices=['file']+[ name for name in dir(crosstexobjects) if isinstance(getattr(crosstexobjects, name), type) and issubclass(getattr(crosstexobjects, name), crosstexobjects.bibobject) ], action='append', help="After parsing the bibliography, dump a list of all objects of the type specified, or, with \"file\", print a list of files processed.")

optparser.add_option('--cite', type='string', action='append', help="Cite a key exactly as with the \\cite LaTeX command.")
optparser.add_option('-l', '--link', metavar='FIELD', type='string', action='append', help="Add to the list of fields used to generate links. LaTeX documents should make use of links by including the hyperref package. When converting to html, this defaults to [Abstract, URL, PS, PDF, HTML, DVI, TEX, BIB, FTP, HTTP, and RTF].")
optparser.add_option('--no-link', action='store_const', const=[], dest='link')

optparser.add_option('--cite-by', type='choice', choices=['number', 'initials', 'fullname'], help="With \"number\", use numeric labels such as [1]. With \"initials\", use labels based on author last-names such as [SBRD04b]. With \"fullname\", use labels based on author names such as [Sirer et al. 04].")
optparser.add_option('--style', type='choice', choices=styles.keys(), action='callback', callback=optstyle, help="Use a standard style such as plain, unsrt, abbrv, full, or alpha.  Options set by the style may be overidden by further command-line options.")

optparser.add_option('-s', '--sort', metavar='FIELD', type='string', action='callback', callback=optsort, help="Sort by specified field. Multiple sort orders are applied in the order specified, e.g. \"-s year -s author\" will cause elements to be grouped primarily by author and sub-grouped by year.")
optparser.add_option('-S', '--reverse-sort', metavar='FIELD', type='string', action='callback', callback=optsort, callback_args=(True,), help="Exactly as --sort, but sort by descending field values rather than ascending.")
optparser.add_option('--no-sort', action='store_const', const=[], dest='sort')

optparser.add_option('--heading', metavar='FIELD', type='string', action='callback', callback=optheading, help="Divide entries and create headings in bibliography by the value of the given field.")
optparser.add_option('--reverse-heading', metavar='FIELD', type='string', action='callback', callback=optheading, callback_args=(True,), help="Divide entries and create headings in bibliography by the value of the given field.")

optparser.add_option('--short', metavar='TYPE', type='choice', choices=[ name for name in dir(crosstexobjects) if isinstance(getattr(crosstexobjects, name), type) and issubclass(getattr(crosstexobjects, name), crosstexobjects.string) ], action='append', help="Specify any string-like object, i.e. one with name and shortname fields. Whenever possible, the short name will be used, e.g. two-letter state codes for \"state\", conference acronyms such as NSDI for \"conference\", or initials such as E. G. Sirer for \"author\".")
optparser.add_option('--add-in', action='store_const', const='In', dest='in_str', help="Add \"In\" for articles.")
optparser.add_option('--add-proc', action='store_const', const='Proc. of', dest='proceedings_str', help="Add \"Proc. of\" for conference and workshop publications.")
optparser.add_option('--add-proceedings', action='store_const', const='Proceedings of the', dest='proceedings_str', help="Add \"Proceedings of the\" for conference and workshop publications.")
optparser.add_option('--abstract', action='store_true', help="In the bibliography, include paper abstracts if available.")
optparser.add_option('--no-abstract', action='store_false', dest='abstract')
optparser.add_option('--keywords', action='store_true', help="In the bibliography, include paper keywords if available.")
optparser.add_option('--no-keywords', action='store_false', dest='keywords')
optparser.add_option('--titlecase', type='choice', choices=['lower', 'upper', 'title', 'default'], help="In the bibliography, force titles into lower-, upper-, or title-case.  Default: Leave titles unchanged.")
optparser.add_option('--title-head', action='store_true', help="In the bibliography, put the title bold and first.")
optparser.add_option('--no-title-head', action='store_false', dest='title_head')
optparser.add_option('--blank-labels', action='store_true', help="In the bibliography, leave out item labels.")
optparser.add_option('--no-blank-labels', action='store_false', dest='blank_labels')
optparser.add_option('--break-lines', action='store_true', help="In the bibliography, put author, title, and publication information on separate lines.")
optparser.add_option('--no-break-lines', action='store_false', dest='break_lines')

optparser.add_option('--xtx2bib', action='callback', callback=optconvert, help="Convert the bibliography information to old-style BibTeX.")
optparser.add_option('--xtx2html', action='callback', callback=optconvert, help="Format the bibliography as HTML.")


# A self-contained bibliographic environment.

class bibliography(dict):
    def __init__(self):
	self.optlist = []
	self.primarykeys = []
	self.aliases = {}
	self.preambles = []
	self._citations = None

    def setoptions(self, optlist):
	global optparser
	self.optlist = optlist + self.optlist
	optparser.set_defaults(
	    check=1,
	    cite=[],
	    cite_by='number',
	    convert='bbl',
	    dir=[topdir, '.'],
	    dump=[],
	    heading=(False, None),
	    in_str='',
	    link=[],
	    proceedings_str='',
	    short=[],
	    sort=[(False, 'month'), (False, 'year'), (False, 'author'), (False, 'label')],
	    titlecase='default',
	)
	(self.options, args) = optparser.parse_args(args=self.optlist)
	self.options.dir.reverse()
	self._citations = None

    def citations(self):
	if self._citations != None:
	    return self._citations
	self._citations = []

	for key in self.options.cite:
	    if key == '*':
		for i in self.primarykeys:
		    if hasattr(self[i], '_label') and i not in self._citations:
			self._citations += [i]
	    else:
		if key in self:
		    if hasattr(self[key], '_label'):
			if self.aliases[key] == key:
			    if key not in self._citations:
				self._citations += [key]
			else:
			    self.warning("crosstex: citation for non-primary key %s" % key)
		    else:
			self.warning("crosstex: %s %s is not citable" % (self[key]._name, key))
		else:
		    self.warning("crosstex: citation for non-existant key %s" % key)

	for reverse, field in self.options.sort:
	    def keyfunc(x):
		try:
		    if field == 'label':
			return self[x]._label()
		    elif field == 'citation':
			return self._citations.index(x)
		    else:
			return getattr(self[x], field)
		except Exception, details:
		    return ''
	    self._citations.sort(key=keyfunc, reverse=reverse)

	self._divided = {}
	if self.options.heading[1] != None:
	    for cite in self._citations:
		key = ''
		if hasattr(self[cite], self.options.heading[1]):
		    key = str(getattr(self[cite], self.options.heading[1]))
		if key not in self._divided:
		    self._divided[key] = []
		self._divided[key].append(cite)
	else:
	    self._divided[''] = self._citations

	return self._citations

    def divided(self):
	self.citations()
	return self._divided

    def addobject(self, name, keys, data, defaults, file, line):
        name = name.strip().lower()
        try:
            obj = getattr(crosstexobjects, name)(data, defaults, file, line, self.options)
            obj._citekey = None
            for key in keys:
                if key in self:
                    other = self[key]
                    if other == obj:
                        raise Warning, "re-definition of %s %s at %s:%d" % (obj._name, key, other._file, other._line)
                    else:
                        raise KeyError, "%s %s is already defined at %s:%d" % (obj._name, key, other._file, other._line)
                else:
                    self[key] = obj
                    if obj._citekey == None:
                        obj._citekey = key
                        self.primarykeys += [key]
                    self.aliases[key] = obj._citekey
	    return obj
        except AttributeError:
	    raise KeyError, "object type %s is not defined" % (name)

    def error(self, message):
	if self.options.check > 0:
	    sys.stderr.write(str(message) + "\n")

    def warning(self, message):
	if self.options.check > 1:
	    sys.stderr.write(str(message) + "\n")

# Lexer

# Tokens
tokens = (
    'AT', 'COMMA', 'SHARP', 'OPENBRACE', 'CLOSEBRACE', 'LBRACK', 'RBRACK', 'EQUALS', 
    'ATINCLUDE', 'ATSTRING', 'ATPREAMBLE', 'ATCOMMENT', 'ATDEFAULT',
    'NUMBER', 'NAME', 'STRING',
    )

def t_COMMENT(t):
    r'\%.*'
    pass
    # No return value. Token discarded

def t_ATINCLUDE(t):
    r'@[iI][nN][cC][lL][uU][dD][eE]'
    t.lexer.followsequals = 0
    return t
    
def t_ATSTRING(t):
    r'@[sS][tT][rR][iI][nN][gG]'
    t.lexer.followsequals = 0
    return t
    
def t_ATPREAMBLE(t):
    r'@[pP][rR][eE][aA][mM][bB][lL][eE]'
    t.lexer.followsequals = 0
    return t

def t_ATCOMMENT(t):
    r'@[Cc][Oo][Mm][Mm][Ee][Nn][Tt]'
    return t

def t_ATDEFAULT(t):
    r'@[Dd][Ee][Ff][Aa][Uu][Ll][Tt]'
    return t
    
def t_NUMBER(t):
    r'\d+'
    t.lexer.followsequals = 1
    return t
    
def t_NUMBER(t):
    r'\d+'
    t.lexer.followsequals = 1
    return t

def t_STRING(t):
    r'"(\\.|[^\\"])*"'
    if t.value.count("{") != t.value.count("}"):
        t.lexer.bib.error("%s:%d: mismatched braces in string" % (t.lexer.file, t.lexer.lineno))
    t.lexer.followsequals = 0
    t.lexer.lineno += t.value.count("\n")
    t.value = t.value[1:-1]
    return t

def t_EQUALS(t):
    r'='
    t.lexer.followsequals = 1
    return t

def t_OPENBRACE(t):
    r'\{'
    # if the open brace is a value, treat it like a string
    if t.lexer.followsequals == 1:
        bracelevel = 1
        # add a char at a time until we have a matching brace
        while bracelevel > 0:
            c = t.lexer.lexdata[t.lexer.lexpos]
            t.lexer.lexpos += 1
            if c == "{" and t.value[-1] != "\\":
                bracelevel += 1
            if c == "}" and t.value[-1] != "\\":
                bracelevel -= 1
            t.value += c
        t.lexer.followsequals = 0
        t.lexer.lineno += t.value.count("\n")
	t.value = t.value[1:-1]
	if re.compile('\d+').match(t.value):
            t.type = "NUMBER"
	else:
	    t.type = "STRING"
    return t

def t_CLOSEBRACE(t):
    r'\}'
    t.lexer.followsequals = 0
    return t

def t_AT(t):
    r'@'
    t.lexer.followsequals = 0
    return t
    
def t_SHARP(t):
    r'\#'
    t.lexer.followsequals = 0
    return t
    
def t_COMMA(t):
    r','
    t.lexer.followsequals = 0
    return t

def t_LBRACK(t):
    r'\['
    t.lexer.followsequals = 0
    return t

def t_RBRACK(t):
    r'\]'
    t.lexer.followsequals = 0
    return t

def t_NAME(t):
    r'[a-zA-Z_][-a-zA-Z:0-9/_]*'
    t.lexer.followsequals = 0
    return t

# Ignored characters
t_ignore = " \t"

def t_newline(t):
    r'\n+'
    t.lexer.lineno += t.value.count("\n")

def t_error(t):
    t.lexer.bib.error("%s:%d: syntax error at '%s'" % (lexer.file, t.lexer.lineno, t.value[0]))
    t.skip(1)
    
# Grammar

# Parsing rules
precedence = ( )

def p_stmt_singleton(t):
    'stmts : stmt'
    pass

def p_stmt_multiple(t):
    'stmts : stmt stmts'
    pass

def p_stmt_object(t):
    'stmt : object'
    t[0] = t[1]

def p_stmt_include(t):
    'stmt : ATINCLUDE NAME'
    filename = t[2]
    processfile(filename, t.lexer.bib, t.lexer.seenfiles, ['.xtx', '.bib', '.aux'])

def p_stmt_preamble(t):
    'stmt : ATPREAMBLE OPENBRACE STRING CLOSEBRACE'
    t.lexer.bib.preambles += [t[3]]

def p_stmt_comment(t):
    'stmt : ATCOMMENT STRING'
    pass

def p_stmt_default(t):
    'stmt : ATDEFAULT field'
    t.lexer.defaults.update(t[2])

def p_stmt_string(t):
    'stmt : ATSTRING OPENBRACE fields CLOSEBRACE'
    for key in t[3]:
	try:
	    t.lexer.bib.addobject('string', [key], [(None, {'name': t[3][key]})], t.lexer.defaults, t.lexer.file, t.lineno(3))._check()
	except Warning, detail:
	    t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
	except Exception, detail:
	    t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))

def p_object_defn(t):
    'object : AT NAME OPENBRACE keys COMMA fields conditionals CLOSEBRACE'
    t[2] = t[2].lower()
    try:
        t.lexer.bib.addobject(t[2], t[4], [(None, t[6])] + t[7], t.lexer.defaults, t.lexer.file, t.lineno(2))._check()
    except Warning, detail:
	t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(2), detail))
    except Exception, detail:
	t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(2), detail))

def p_object_error(t):
    'object : error CLOSEBRACE'
    pass

def p_keys_singleton(t):
    'keys : NAME'
    t[0] = [t[1]]

def p_keys_multiple(t):
    'keys : NAME EQUALS keys'
    t[0] = [t[1]] + t[3]

def p_conditionals_empty(t):
    'conditionals :'
    t[0] = []

def p_conditionals_singleton(t):
    'conditionals : conditional'
    t[0] = [t[1]]

def p_conditionals_multiple(t):
    'conditionals : conditional conditionals'
    t[0] = [t[1]] + t[2]

def p_conditional(t):
    'conditional : LBRACK fields RBRACK fields'
    t[0] = (t[2], t[4])

def p_fields_empty(t):
    'fields :'
    t[0] = []

def p_fields_singleton(t):
    'fields : field'
    t[0] = t[1]

def p_fields(t):
    'fields : field COMMA fields'
    t[0] = t[1]
    t[0].update(t[3])
              
def p_field(t):
    'field : NAME EQUALS value'
    t[1] = t[1].lower()
    if t[1] == 'author' or t[1] == 'editor':
	values = crosstexobjects.authorlist(t.lexer.bib.options)
	if isinstance(t[3], str):
	    for key in re.compile('\s+and\s+').split(t[3]):
		if key in t.lexer.bib:
		    values += [t.lexer.bib[key]]
		else:
		    try:
			t.lexer.bib.addobject('author', [key], [(None, {'name': key})], t.lexer.defaults, t.lexer.file, t.lineno(3))._check()
			values += [t.lexer.bib[key]]
		    except Warning, detail:
			t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
		    except Exception, detail:
			t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
			raise
	else:
	    values += [t[3]]
	t[0] = {t[1]: values}
    else:
	t[0] = {t[1]: t[3]}

def p_value_singleton(t):
    'value : simplevalue'
    t[0] = t[1]

def p_value_concat(t):
    'value : value SHARP simplevalue'
    t[0] = t[1].rstrip("\"") + t[3].lstrip("\"")

def p_simplevalue_number(t):
    'simplevalue : NUMBER'
    t[0] = t[1]
    
def p_simplevalue_name(t):
    'simplevalue : NAME'
    key = t[1]
    if key in t.lexer.bib:
	t[0] = t.lexer.bib[key]
    else:
	t.lexer.bib.error("%s:%d: undefined reference to object %s; using it as a string" % (t.lexer.file, t.lineno(1), key))
	t[0] = t[1]
    
def p_simplevalue_string(t):
    'simplevalue : STRING'
    t[0] = t[1]

def p_error(t):
    t.lexer.bib.error("%s:%d: parse error at '%s'" % (t.lexer.file, t.lexer.lineno, t.value[0]))

def processfile(infilename, bib, seenfiles=set(), exts=['.aux', '.xtx', '.bib']):
    if infilename in seenfiles:
	if 'file' in bib.options.dump:
            sys.stderr.write("File %s already processed, skipping.\n" % infilename)
	return

    names = []
    if infilename[infilename.rfind('.'):] in exts:
	names = [infilename]
    else:
	names = [infilename + ext for ext in exts]

    paths = []
    if infilename[0] == '/':
	paths = names
    else:
	for path in bib.options.dir:
	    paths.extend(['/'.join([path, name]) for name in names])

    for filename in paths:
	try:
	    instream = open(filename, 'r')
	    if 'file' in bib.options.dump:
		sys.stderr.write("Processing %s...\n" % filename)
	    if filename.endswith('.aux'):
		parseaux(instream, infilename, bib, seenfiles)
	    else:
		parsextx(instream, infilename, bib, seenfiles)
	    instream.close()
	    seenfiles.add(infilename)
	    return filename
	except:
	    continue
    else:
        raise IOError, '%s does not exist or is not a bibliographic database' % infilename

def parseaux(instream, infilename, bib, seenfiles):
    options = []
    datafiles = []
    while 1:
        line = instream.readline()
        if not line:
            break
        if line[0:9] == "\\citation":
            citeline = line[10:].strip().rstrip("}")
            for cite in citeline.split(","):
                if cite.find(" ") >= 0:
                    bib.error("citation with empty space \"%s\"" % cite)
                else:
		    cite = cite.strip(", 	")
		    if cite == "":
			bib.error("empty citation, check for spurious commas in \\cite{} commands")
		    else:
			options.extend(['--cite', cite])
        elif line[0:9] == "\\bibstyle":
	    options.extend(['--style'] + line[10:].rstrip().rstrip("}").split(','))
        elif line[0:8] == "\\bibdata":
            datafiles.extend(line[9:].rstrip().rstrip("}").split(','))
    bib.setoptions(options)
    for datafile in datafiles:
	try:
	    processfile(datafile, bib, seenfiles, ['.xtx', '.bib', '.aux'])
	except:
	    bib.error("Could not process data file %s" % datafile)
    
def parsextx(instream, infilename, bib, seenfiles):
    lexer = lex.lex()
    lexer.bib = bib
    lexer.file = infilename
    lexer.lineno = 1
    lexer.seenfiles = seenfiles
    lexer.followsequals = 0
    lexer.defaults = {}
    parser = yacc.yacc(debug=0, write_tables=0) # set these to 1 for icky debugging
    parser.parse(instream.read(), lexer=lexer)


namearg = '--' + sys.argv[0].split('/')[-1]
if optparser.has_option(namearg):
    sys.argv.insert(1, namearg)

(options, args) = optparser.parse_args()
if len(args) == 0:
    optparser.print_help()
    sys.exit(0)

for infilename in args:
    # Use a different environment for each file.
    bib = bibliography()
    bib.setoptions(sys.argv[1:])

    # Parse the file.
    outfile = None
    filename = None
    try:
	filename = processfile(infilename, bib)
	outfilename = filename.split('/')[-1]
	outfilename = outfilename[:outfilename.rfind('.') + 1] + bib.options.convert
	try:
	    if bib.options.convert == 'html':
		t = pipes.Template()
		t.append('hevea -O', '--')
		outfile = t.open(outfilename, 'w')
	    else:
		outfile = open(outfilename, 'w')
	except:
	    raise IOError, "unable to open output file %s" % outfilename
    except Exception, details:
	bib.error("crosstex: unable to process file %s: %s" % (infilename, details))
	continue

    if len(bib.options.cite) == 0 and not filename.endswith('.aux'):
	bib.setoptions(['--cite', '*'])

    # Handle dump-locations, dump-conferences, etc.
    for objtype in set(bib.options.dump):
	objs = [ "%s\t%s\n" % (key, bib[key]) for key in bib.primarykeys if hasattr(crosstexobjects, objtype) and isinstance(bib[key], getattr(crosstexobjects, objtype)) ]
	if len(objs) != 0:
	    sys.stderr.write("%s\n" % (objtype.upper() + ':'))
	    for i in objs:
	        sys.stderr.write(i)

    # Print headers required by output format.
    if bib.options.convert == 'bib':
	for i in bib.preambles:
	    outfile.write("@PREAMBLE { \"" + i + "\" }\n\n")
    else:
	if bib.options.convert == 'html':
	    outfile.write("\\documentclass{report}\n")
	    outfile.write("\\usepackage{hyperref}\n")
	    outfile.write("\\begin{document}\n")
	for i in bib.preambles:
	    outfile.write(i)
	    outfile.write("\n")
	if bib.options.blank_labels:
	    outfile.write("\\makeatletter\\def\\@biblabel#1{}\\makeatother\n")
        if bib.options.break_lines:
	    outfile.write("\\renewcommand{\\newblock}{\\\\}")
	outfile.write("\\newcommand{\\etalchar}[1]{$^{#1}$}\n")

    # Format each titled section.
    divided = bib.divided()
    headings = divided.keys()
    headings.sort()
    if bib.options.heading[0]:
	headings.reverse()
    for heading in headings:
	if heading == '':
	    continue
	maxstr = ''
	for key in divided[heading]:
	    citekey = bib[key]._label().replace("{\\etalchar{+}}", "X")
	    if len(citekey) > len(maxstr):
		maxstr = citekey
	if len(divided[heading]) != 0:
	    strlen = int(math.ceil(math.log(len(divided[heading]), 10)))
	    if maxstr == "":
		maxstr = "00000000000"[0:strlen]
	    elif len(maxstr) >= 13:
		maxstr = "XXXXXXXXXXXXX"
	else:
	    maxstr = "X"
	outfile.write("{\\renewcommand{\\refname}{%s}\n" % heading)
	outfile.write("\\begin{thebibliography}{" + maxstr + "}\n")
	for key in divided[heading]:
	    outfile.write(str(bib[key]))
        outfile.write("\\end{thebibliography}}\n")

    # Format the rest of the bibliography.
    if '' in divided:
	maxstr = ''
	for key in divided['']:
	    citekey = bib[key]._label().replace("{\\etalchar{+}}", "X")
	    if len(citekey) > len(maxstr):
		maxstr = citekey
	if len(divided['']) != 0:
	    strlen = int(math.ceil(math.log(len(divided['']), 10)))
	    if maxstr == "":
		maxstr = "00000000000"[0:strlen]
	    elif len(maxstr) >= 13:
		maxstr = "XXXXXXXXXXXXX"
	else:
	    maxstr = "X"
	outfile.write("\\begin{thebibliography}{" + maxstr + "}\n")
	for key in divided['']:
	    outfile.write(str(bib[key]))
	outfile.write("\\end{thebibliography}\n")

    # Print footers required by output format.
    if bib.options.convert == 'html':
	outfile.write("\\end{document}\n")
    outfile.close()
