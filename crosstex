#! /usr/bin/env python
#
# CROSSTEX: This is a new, object-oriented cross-referencing engine, to
#         replace BIBTEX.
#
# (c) August 2006, Emin Gun Sirer
# Distributed under the GNU Public License, v2
# See the file COPYING for copyright info
#
#         Features:
#         Object-oriented: Need only enter conference, workshop, venue, etc
#            information once, no need to reenter everything under every descriptor
#            as is required in the relational bibtex model
#         Can generate short or long form references: Suitable for the space crunch as well
#            as formal, long-form references.
#         Capitalization works: Things get capitalized the way they appear in the references.
#         Include files: A bibliography can be broken up into modular units.
#         Sanity checking: Running crosstex on a bib/xtx file will check all entries for conformance.
#         Supports entries with multiple keys, e.g. @book{x=y=z, author=...}
#         Backwards compatible with bibtex
#         Can generate bibtex output: if you must use a bibtex style file, you can
#
import sys
topdir = "/usr/share/texmf/crosstex"
sys.path.append(topdir)

import ply.lex as lex
import ply.yacc as yacc

import copy
import math
import re
import string

import crosstexobjects


# Pre-defined styles.

styles = {
    'abbrv': {
	'use-initials': True,
	'cite-by': 'initials',
	'use-unsorted': False,
	'add-proceedingsof': False,
	'add-procof': False,
	'use-infforarticles': False,
    },
    'alpha': {
	'use-initials': False,
	'cite-by': 'initials',
	'use-unsorted': False,
	'add-proceedingsof': False,
	'add-procof': False,
	'use-infforarticles': False,
    },
    'full': {
	'use-initials': False,
	'cite-by': 'fullname',
	'use-unsorted': False,
	'add-proceedingsof': True,
	'add-procof': False,
	'use-infforarticles': True,
    },
    'unsrt': {
	'use-initials': False,
	'cite-by': 'number',
	'use-unsorted': True,
	'add-proceedingsof': False,
	'add-procof': False,
	'use-infforarticles': False,
    },
    'plain': {
	'use-initials': False,
	'cite-by': 'number',
	'use-unsorted': False,
	'add-proceedingsof': False,
	'add-procof': False,
	'use-infforarticles': False,
    },
}


# An entire bibliographic environment.

class bibliography(dict):
    primarykeys = []
    aliases = {}
    citations = []
    preambles = []
    options = {}

    def cite(self, key):
	self.citations += [key]

    def cleanupkeys(self):
	unique = []
	for key in self.citations:
	    if key in self:
		if hasattr(self[key], '_sortkey'):
		    if self.aliases[key] != key:
			self.error("crosstex: citation for non-primary key %s" % key)
		    elif key not in unique:
		        unique += [self.aliases[key]]
		elif 'cite-all' not in self.options or not self.options['cite-all']:
		    self.error("crosstex: %s %s is not citable" % (self[key]._name, key))
	    else:
		self.error("crosstex: unknown citation key %s" % key)
	self.citations = unique

	if 'use-unsorted' not in self.options or not self.options['use-unsorted']:
	    sortedcitations = [ (self[key]._sortkey(), key) for key in self.citations ]
	    sortedcitations.sort()
	    self.citations = [ key for _, key in sortedcitations ]

    def addobject(self, name, keys, data, file, line, options):
        name = name.strip().lower()
        try:
            obj = getattr(crosstexobjects, name)(data, file, line, options)
        except AttributeError:
	    raise KeyError, "object type %s is not defined" % (name)
        else:
            obj._citekey = None
            for key in keys:
                if key in self:
                    other = self[key]
                    if other == obj:
                        raise Warning, "re-definition of %s %s at %s:%d" % (obj._name, key, other._file, other._line)
                    else:
                        raise KeyError, "%s %s is already defined at %s:%d" % (obj._name, key, other._file, other._line)
                else:
                    self[key] = obj
                    if obj._citekey == None:
                        obj._citekey = key
                        self.primarykeys += [key]
                    self.aliases[key] = obj._citekey

    def error(self, message):
	if 'quiet' not in self.options or not self.options['quiet']:
	    sys.stderr.write(str(message) + "\n")

    def warning(self, message):
	if 'strict' in self.options and self.options['strict']:
	    sys.stderr.write(str(message) + "\n")

# Lexer

# Tokens
tokens = (
    'AT', 'COMMA', 'SHARP', 'OPENBRACE', 'CLOSEBRACE', 'LBRACK', 'RBRACK', 'EQUALS', 
    'ATINCLUDE', 'ATSTRING', 'ATPREAMBLE', 'ATCOMMENT',
    'NUMBER', 'NAME', 'STRING',
    )

def t_COMMENT(t):
    r'\%.*'
    pass
    # No return value. Token discarded

def t_ATINCLUDE(t):
    r'@[iI][nN][cC][lL][uU][dD][eE]'
    t.lexer.followsequals = 0
    return t
    
def t_ATSTRING(t):
    r'@[sS][tT][rR][iI][nN][gG]'
    t.lexer.followsequals = 0
    return t
    
def t_ATPREAMBLE(t):
    r'@[pP][rR][eE][aA][mM][bB][lL][eE]'
    t.lexer.followsequals = 0
    return t

def t_ATCOMMENT(t):
    r'@[Cc][Oo][Mm][Mm][Ee][Nn][Tt]'
    return t
    
def t_NUMBER(t):
    r'\d+'
    t.lexer.followsequals = 1
    return t

def t_STRING(t):
    r'"(\\.|[^\\"])*"'
    if t.value.count("{") != t.value.count("}"):
        t.lexer.bib.error("%s:%d: mismatched braces in string" % (t.lexer.file, t.lexer.lineno))
    t.lexer.followsequals = 0
    t.lexer.lineno += t.value.count("\n")
    t.value = t.value[1:-1]
    return t

def t_EQUALS(t):
    r'='
    t.lexer.followsequals = 1
    return t

def t_OPENBRACE(t):
    r'\{'
    # if the open brace is a value, treat it like a string
    if t.lexer.followsequals == 1:
        bracelevel = 1
        # add a char at a time until we have a matching brace
        while bracelevel > 0:
            c = t.lexer.lexdata[t.lexer.lexpos]
            t.lexer.lexpos += 1
            if c == "{" and t.value[-1] != "\\":
                bracelevel += 1
            if c == "}" and t.value[-1] != "\\":
                bracelevel -= 1
            t.value += c
        t.lexer.followsequals = 0
        t.lexer.lineno += t.value.count("\n")
	t.value = t.value[1:-1]
	if re.compile('\d+').match(t.value):
            t.type = "NUMBER"
	else:
	    t.type = "STRING"
    return t

def t_CLOSEBRACE(t):
    r'\}'
    t.lexer.followsequals = 0
    return t

def t_AT(t):
    r'@'
    t.lexer.followsequals = 0
    return t
    
def t_SHARP(t):
    r'\#'
    t.lexer.followsequals = 0
    return t
    
def t_COMMA(t):
    r','
    t.lexer.followsequals = 0
    return t

def t_LBRACK(t):
    r'\['
    t.lexer.followsequals = 0
    return t

def t_RBRACK(t):
    r'\]'
    t.lexer.followsequals = 0
    return t

def t_NAME(t):
    r'[a-zA-Z_][-a-zA-Z:0-9/_]*'
    t.lexer.followsequals = 0
    return t

# Ignored characters
t_ignore = " \t"

def t_newline(t):
    r'\n+'
    t.lexer.lineno += t.value.count("\n")

def t_error(t):
    t.lexer.bib.error("%s:%d: syntax error at '%s'" % (lexer.file, t.lexer.lineno, t.value[0]))
    t.skip(1)
    
# Grammar

# Parsing rules
precedence = ( )

def p_stmt_singleton(t):
    'stmts : stmt'
    pass

def p_stmt_multiple(t):
    'stmts : stmt stmts'
    pass

def p_stmt_object(t):
    'stmt : object'
    t[0] = t[1]

def p_stmt_include(t):
    'stmt : ATINCLUDE NAME'
    filename = t[2]
    parsextxfile(filename, t.lexer.bib, t.lexer.seenfiles)

def p_stmt_preamble(t):
    'stmt : ATPREAMBLE OPENBRACE STRING CLOSEBRACE'
    t.lexer.bib.preambles += [t[3]]

def p_stmt_comment(t):
    'stmt : ATCOMMENT STRING'
    pass

def p_stmt_string(t):
    'stmt : ATSTRING OPENBRACE fields CLOSEBRACE'
    for key in t[3]:
	try:
	    t.lexer.bib.addobject('string', [key], [(None, {'name': t[3][key]})], t.lexer.file, t.lineno(3), t.lexer.bib.options)
	except Warning, detail:
	    t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
	except Exception, detail:
	    t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))

def p_object_defn(t):
    'object : AT NAME OPENBRACE keys COMMA fields conditionals CLOSEBRACE'
    try:
        t.lexer.bib.addobject(t[2], t[4], [(None, t[6])] + t[7], t.lexer.file, t.lineno(2), t.lexer.bib.options)
    except Warning, detail:
	t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(2), detail))
    except Exception, detail:
	t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(2), detail))

def p_object_error(t):
    'object : error CLOSEBRACE'
    pass

def p_keys_singleton(t):
    'keys : NAME'
    t[0] = [t[1]]

def p_keys_multiple(t):
    'keys : NAME EQUALS keys'
    t[0] = [t[1]] + t[3]

def p_conditionals_empty(t):
    'conditionals :'
    t[0] = []

def p_conditionals_singleton(t):
    'conditionals : conditional'
    t[0] = [t[1]]

def p_conditionals_multiple(t):
    'conditionals : conditional conditionals'
    t[0] = [t[1]] + t[2]

def p_conditional(t):
    'conditional : LBRACK fields RBRACK fields'
    t[0] = (t[2], t[4])

def p_fields_empty(t):
    'fields :'
    t[0] = []

def p_fields_singleton(t):
    'fields : field'
    t[0] = t[1]

def p_fields(t):
    'fields : field COMMA fields'
    t[0] = t[1]
    t[0].update(t[3])
              
def p_field(t):
    'field : NAME EQUALS value'
    if t[1] == 'author':
	values = crosstexobjects.authorlist(t.lexer.bib.options)
	if isinstance(t[3], str):
	    for key in re.compile('\s+and\s+').split(t[3]):
		if key in t.lexer.bib:
		    values += [t.lexer.bib[key]]
		else:
		    values += [key]
	else:
	    values += [t[3]]
	t[0] = {t[1]: values}
    else:
	t[0] = {t[1]: t[3]}

def p_value_singleton(t):
    'value : simplevalue'
    t[0] = t[1]

def p_value_concat(t):
    'value : value SHARP simplevalue'
    t[0] = t[1].rstrip("\"") + t[3].lstrip("\"")

def p_simplevalue_number(t):
    'simplevalue : NUMBER'
    t[0] = t[1]
    
def p_simplevalue_name(t):
    'simplevalue : NAME'
    key = t[1]
    if key in t.lexer.bib:
	t[0] = t.lexer.bib[key]
    else:
	t.lexer.bib.error("%s:%d: undefined reference to object %s; using it as a string" % (t.lexer.file, t.lineno(1), key))
	t[0] = t[1]
    
def p_simplevalue_string(t):
    'simplevalue : STRING'
    t[0] = t[1]

def p_error(t):
    t.lexer.bib.error("%s:%d: parse error at '%s'" % (t.lexer.file, t.lexer.lineno, t.value[0]))
        
def parseauxfile(infilename, bib=bibliography()):
    if infilename[-4:] != ".aux":
        infilename = infilename + ".aux"
    if 'dump-files' in bib.options and bib.options['dump-files']:
        sys.stderr.write("Processing file %s...\n" % infilename)
    try:
        infile = open(infilename, 'r')
    except:
        bib.error("crosstex: file %s does not exist" % infilename)
        sys.exit(1)
    parseaux(infile, infilename, bib)
    infile.close()

# parses the AUX file and builds a list of citations
def parseaux(instream, infilename, bib):
    seenfiles = set()
    while 1:
        line = instream.readline()
        if not line:
            break
        if line[0:9] == "\\citation":
            citeline = line[10:].strip().rstrip("}")
            for cite in citeline.split(","):
                if cite.find(" ") >= 0:
                    bib.error("citation with empty space \"%s\"" % cite)
                    if bib.citations != []:
                        bib.error("    last good citation was", bib.citations[len(bib.citations)-1])
                cite = cite.strip(", 	")
                if cite == "*":
                    bib.options["cite-all"] = True
                    continue
                elif cite == "":
                    bib.error("empty citation, check for spurious commas in \\cite{} commands")
                    if bib.citations != []:
                        bib.error("    last good citation was", bib.citations[len(bib.citations)-1])
		bib.cite(cite)
        elif line[0:9] == "\\bibstyle":
            sname = line[10:].rstrip().rstrip("}")
	    try:
                style(sname, bib.options)
	    except Exception, detail:
		bib.error(detail)
        elif line[0:8] == "\\bibdata":
            fnamesfull = line[9:].rstrip().rstrip("}")
            fnames = fnamesfull.split(",")
            for fname in fnames:
                parsextxfile(fname, bib, seenfiles)
            
def pathopen(name, mode, bib):
    if name[0] == "/":
        if 'dump-files' in bib.options and bib.options['dump-files']:
            sys.stderr.write("Processing %s...\n" % name)
        return open(name, mode)

    # filename is relative, try all elements of the path
    for path in bib.options["path"].split(":"):
        try:
             file = open(path + "/" + name, mode)
             if 'dump-files' in bib.options and bib.options['dump-files']:
                 sys.stderr.write("Processing %s...\n" % (path + "/" + name))
             return file
        except:
             pass
    raise IOError, 'File not found'
    
def parsextxfile(infilename, bib=bibliography(), seenfiles=set()):
    suffixes = [".xtx", ".bib"]
    if 'dump-files' in bib.options and bib.options['dump-files']:
        sys.stderr.write("Processing file %s...\n" % infilename)
    if infilename in seenfiles:
	if 'dump-files' in bib.options and bib.options['dump-files']:
            sys.stderr.write("File %s already processed, skipping.\n" % infilename)
	return
    for suffix in suffixes:
        if not infilename.endswith(suffix):
            filename = infilename + suffix
        else:
            filename = infilename
        try:
            infile = pathopen(filename, 'r', bib)
            # we get here only if we succeed
	    seenfiles.add(infilename)
	    parsextx(infile, filename, bib, seenfiles)
            infile.close()
	    return
        except IOError:
	    pass
    else:
        bib.error("Bibliography database %s not found, skipping" % infilename)
        return
    
# parses the XTX file and builds an object hierarchy
def parsextx(instream, infilename, bib, seenfiles):
    # Build the lexer and initialize the parser
    global topdir
    lexer = lex.lex()
    lexer.bib = bib
    lexer.file = infilename
    lexer.lineno = 1
    lexer.seenfiles = seenfiles
    lexer.followsequals = 0
    #parser = yacc.yacc(debug=1, write_tables=1)
    parser = yacc.yacc(debug=0, write_tables=0)
    parser.parse(instream.read(), lexer=lexer)

def style(style, options):
    global styles
    if style not in styles:
	raise Warning, "unkown bibliography style %s" % style
    options.update(styles[style])

def usage():
    print "crosstex [options] filename"
    print ""
    print " General Options"
    print "  --path /path1:/path2:\tuse path to look for files (default=.:%s)" % topdir
    print ""
    print " Options for reference appearance in the bibliography:"
    print "  --use-short-conferencenames:\tuse short conference names"
    print "  --use-short-monthnames:\tuse three/four letter short month prefix"
    print "  --use-short-statenames:\tuse use two letter abbreviation for state"
    print "  --use-short-countrynames:\tuse short country name where possible"
    print "  --use-short-journalnames:\tuse short journal name where possible"
    print "  --add-proceedingsof:\t\tadd \"Proceedings of the\" for conf and workshop publications"
    print "  --add-procof:\t\t\tadd \"Proc. of\" for conf and workshop publications"
    print "  --use-inforarticles:\t\tadd \"In\" for articles"
    print "  --title-lowercase:\t\tmake titles all lowercase"
    print "  --title-uppercase:\t\tmake titles all uppercase"
    print "  --title-titlecase:\t\tmake titles in titlecase"
    print "  --use-initials:\t\tShorten first names in bib entries to just initials"
    print "  --use-unsorted:\t\tLeave the bibliography in citation order"
    print "  --cite-all:\t\tImplicitly cite all entries in the bibliography"
    print ""
    print " Options for citation style:"
    print "  --style name:\t\t\tOverride with named style, e.g. plain, unsrt, abbrv, full, alpha"
    print "  --cite-by number:\t\tRefer to papers by numbers, e.g. [1] (default)"
    print "  --cite-by initials:\t\tRefer to papers by concatenation of lastname initials, e.g. [SBRD04b]"
    print "  --cite-by fullname:\t\tRefer to papers by last names, e.g. [Sirer et al. 04]"
    print ""
    print " Sanity checking of the object database:"
    print "  --quiet:\t\t\tdo not sanity check the input"
    print "  --strict:\t\t\tapply stricter checks"
    print ""
    print " Debugging:"
    print "  --dump-locations:\t\tdump the location data for debugging"
    print "  --dump-conferences:\t\tdump the conference data for debugging"
    print "  --dump-workshops:\t\tdump the workshop data for debugging"
    print "  --dump-files:\t\t\tdump the input files processed"
    print ""
    print " Conversion:"
    print "  --xtx2bib:\t\t\tconvert to plain BibTeX on standard output"
    print ""
    print " Options override defaults from .aux files"
    print " De-activate a boolean option with e.g. --no-option-name"
    sys.exit(1)

if int(len(sys.argv) == 0):
    usage()

options = {}

# The symlink from "xtx2bib" to this file turns on the xtx2bib option.
pathcomponents = sys.argv[0].split("/")
basename = pathcomponents[len(pathcomponents)-1]
options[basename] = True

# Parse arguments.
nopt = 1
for opt in sys.argv[1:]:
    if opt == "--help":
        usage()
    elif opt == "--path" or opt == "--cite-by":
        if len(sys.argv) <= nopt+1:
            usage()
        else:
            options[opt[2:]] = sys.argv[nopt+1]
            nopt += 2
    elif opt == "--style":
        if len(sys.argv) <= nopt+1:
            usage()
        else:
	    try:
	        style(sys.argv[nopt+1], options)
	    except Exception, detail:
		sys.stderr.write("crosstex: %s\n" % detail)
            nopt += 2
    elif len(opt) >= 5 and opt[0] == "-" and opt[1] == "-" and opt[2] == "n" and opt[3] == "o" and opt[4] == "-":
        options[opt[5:]] = False
        nopt += 1
    elif len(opt) >= 2 and opt[0] == "-" and opt[1] == "-":
        options[opt[2:]] = True
        nopt += 1

if nopt >= len(sys.argv):
  usage()

if 'xtx2bib' in options and options['xtx2bib']:
    options['cite-all'] = 1

if 'path' not in options:
    options['path'] = ".:%s" % topdir

for infilename in sys.argv[nopt:]:

    # Use a difference environment for each file.
    bib = bibliography()
    bib.options.update(options)

    # Parse the file.
    if infilename[-4:] == ".xtx" or infilename[-4:] == ".bib":
        parsextxfile(infilename, bib)
        bblfilename = None
    else:
        parseauxfile(infilename, bib)
        bblfilename = infilename + ".bbl"
    if 'xtx2bib' in bib.options and bib.options['xtx2bib']:
	bblfilename = None

    # Ensure command-line arguments overwrite options in any .aux files.
    bib.options.update(options)

    # Handle dump-locations, dump-conferences, etc.
    for option in bib.options:
	if option.startswith('dump-') and option[5:-1] in dir(crosstexobjects) and bib.options[option]:
	    dumpclass = option[5:-1].lower()
	    sys.stderr.write("%s\n" % (option[5:].upper() + ':'))
	    for key in bib.primarykeys:
		if bib[key]._name == dumpclass:
		    sys.stderr.write("%s\t%s\n" % (key, bib[key]))

    # Clean up the citation list, including sorting if necessary.
    if 'cite-all' in bib.options and bib.options['cite-all']:
	for key in bib.primarykeys:
	    try:
		bib.cite(key)
	    except:
		pass
    bib.cleanupkeys()

    # Print headers required by output format.
    if bblfilename != None:
	outfile = open(bblfilename, 'w')
    else:
	outfile = sys.stdout
    if 'xtx2bib' in bib.options and bib.options['xtx2bib']:
	for i in bib.preambles:
	    outfile.write("@PREAMBLE {" + i + "}\n\n")
    else:
	outfile.write("\\newcommand{\\etalchar}[1]{$^{#1}$}\n")
	for i in bib.preambles:
	    outfile.write(i)
	    outfile.write("\n")
	maxstr = ''
	for key in bib.citations:
	    citekey = key.replace("{\\etalchar{+}}", "X")
	    if len(citekey) > len(maxstr):
		maxstr = citekey
	if len(bib.citations) != 0:
	    strlen = int(math.ceil(math.log(len(bib.citations), 10)))
	    if maxstr == "":
		maxstr = "00000000000"[0:strlen]
	    elif len(maxstr) >= 13:
                maxstr = "XXXXXXXXXXXXX"
	else:
	    maxstr = "X"
	outfile.write("\\begin{thebibliography}{" + maxstr + "}\n")

    # Format each cited work.
    for key in bib.citations:
	outfile.write(str(bib[key]))

    # Print footers required by output format.
    if 'xtx2bib' in bib.options and bib.options['xtx2bib']:
	pass
    else:
        outfile.write("\\end{thebibliography}\n")
    outfile.close()
