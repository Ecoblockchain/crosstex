#! /usr/bin/env python
#
# CROSSTEX: This is a new, object-oriented cross-referencing engine, to
#         replace BIBTEX.
#
# (c) August 2006, Emin Gun Sirer
# Distributed under the GNU Public License, v2
# See the file COPYING for copyright info
#
#         Features:
#         Object-oriented: Need only enter conference, workshop, venue, etc
#            information once, no need to reenter everything under every descriptor
#            as is required in the relational bibtex model
#         Can generate short or long form references: Suitable for the space crunch as well
#            as formal, long-form references.
#         Capitalization works: Things get capitalized the way they appear in the references.
#         Include files: A bibliography can be broken up into modular units.
#         Sanity checking: Running crosstex on a bib/xtx file will check all entries for conformance.
#         Supports entries with multiple keys, e.g. @book{x=y=z, author=...}
#         Backwards compatible with bibtex
#         Can generate bibtex output: if you must use a bibtex style file, you can
#
import sys
topdir = "/usr/share/texmf/crosstex"
sys.path.append(topdir)

import ply.lex as lex
import ply.yacc as yacc

import copy
import math
import pipes
import re
import string
import tempfile

import crosstexobjects


# Pre-defined styles.

styles = {
    'abbrv': {
	'use-short-authornames': True,
	'cite-by': 'initials',
    },
    'alpha': {
	'cite-by': 'initials',
    },
    'full': {
	'cite-by': 'fullname',
	'add-proceedingsof': True,
	'use-infforarticles': True,
    },
    'unsrt': {
	'cite-by': 'number',
	'sort': '',
    },
    'plain': {
    },
    'html': {
	'links': 'Abstract,URL,PS,PDF,HTML,DVI,TEX,BIB,FTP,HTTP,RTF',
	'break-lines': True,
    },
    'xtx2html': {
	'links': 'Abstract,URL,PS,PDF,HTML,DVI,TEX,BIB,FTP,HTTP,RTF',
	'break-lines': True,
	'blank-labels': True,
	'title-head': True,
	'abstract': True,
	'keywords': True,
    },
}


# An entire bibliographic environment.

class bibliography(dict):
    primarykeys = []
    aliases = {}
    citations = []
    preambles = []
    options = {}

    def cite(self, key):
	if key == '*':
	    for i in self.primarykeys:
		if hasattr(self[i], '_label') and i not in self.citations:
		    self.citations += [i]
	else:
	    if key in self:
		if hasattr(self[key], '_label'):
		    if self.aliases[key] == key:
			if key not in self.citations:
			    self.citations += [key]
		    else:
			self.warning("crosstex: citation for non-primary key %s" % key)
		else:
		    self.warning("crosstex: %s %s is not citable" % (self[key]._name, key))
	    else:
		self.warning("crosstex: citation for non-existant key %s" % key)

    def sortcitations(self):
        if 'sort' in self.options and self.options['sort'] != '':
	    keys = self.options['sort'].split(',')
	    keys.reverse()
	    for key in keys:
		reverse = False
		if key[0] == '-':
		    reverse = True
		    key = key[1:]
		def keyfunc(x):
		    try:
			if key == 'label':
			    return self[x]._label()
			else:
			    return getattr(self[x], key)
		    except Exception, details:
			return ''
	        self.citations.sort(key=keyfunc, reverse=reverse)

    def addobject(self, name, keys, data, file, line, options):
        name = name.strip().lower()
        try:
            obj = getattr(crosstexobjects, name)(data, file, line, options)
        except AttributeError:
	    raise KeyError, "object type %s is not defined" % (name)
        else:
            obj._citekey = None
            for key in keys:
                if key in self:
                    other = self[key]
                    if other == obj:
                        raise Warning, "re-definition of %s %s at %s:%d" % (obj._name, key, other._file, other._line)
                    else:
                        raise KeyError, "%s %s is already defined at %s:%d" % (obj._name, key, other._file, other._line)
                else:
                    self[key] = obj
                    if obj._citekey == None:
                        obj._citekey = key
                        self.primarykeys += [key]
                    self.aliases[key] = obj._citekey

    def error(self, message):
	if 'quiet' not in self.options or not self.options['quiet']:
	    sys.stderr.write(str(message) + "\n")

    def warning(self, message):
	if 'strict' in self.options and self.options['strict']:
	    sys.stderr.write(str(message) + "\n")

# Lexer

# Tokens
tokens = (
    'AT', 'COMMA', 'SHARP', 'OPENBRACE', 'CLOSEBRACE', 'LBRACK', 'RBRACK', 'EQUALS', 
    'ATINCLUDE', 'ATSTRING', 'ATPREAMBLE', 'ATCOMMENT',
    'NUMBER', 'NAME', 'STRING',
    )

def t_COMMENT(t):
    r'\%.*'
    pass
    # No return value. Token discarded

def t_ATINCLUDE(t):
    r'@[iI][nN][cC][lL][uU][dD][eE]'
    t.lexer.followsequals = 0
    return t
    
def t_ATSTRING(t):
    r'@[sS][tT][rR][iI][nN][gG]'
    t.lexer.followsequals = 0
    return t
    
def t_ATPREAMBLE(t):
    r'@[pP][rR][eE][aA][mM][bB][lL][eE]'
    t.lexer.followsequals = 0
    return t

def t_ATCOMMENT(t):
    r'@[Cc][Oo][Mm][Mm][Ee][Nn][Tt]'
    return t
    
def t_NUMBER(t):
    r'\d+'
    t.lexer.followsequals = 1
    return t

def t_STRING(t):
    r'"(\\.|[^\\"])*"'
    if t.value.count("{") != t.value.count("}"):
        t.lexer.bib.error("%s:%d: mismatched braces in string" % (t.lexer.file, t.lexer.lineno))
    t.lexer.followsequals = 0
    t.lexer.lineno += t.value.count("\n")
    t.value = t.value[1:-1]
    return t

def t_EQUALS(t):
    r'='
    t.lexer.followsequals = 1
    return t

def t_OPENBRACE(t):
    r'\{'
    # if the open brace is a value, treat it like a string
    if t.lexer.followsequals == 1:
        bracelevel = 1
        # add a char at a time until we have a matching brace
        while bracelevel > 0:
            c = t.lexer.lexdata[t.lexer.lexpos]
            t.lexer.lexpos += 1
            if c == "{" and t.value[-1] != "\\":
                bracelevel += 1
            if c == "}" and t.value[-1] != "\\":
                bracelevel -= 1
            t.value += c
        t.lexer.followsequals = 0
        t.lexer.lineno += t.value.count("\n")
	t.value = t.value[1:-1]
	if re.compile('\d+').match(t.value):
            t.type = "NUMBER"
	else:
	    t.type = "STRING"
    return t

def t_CLOSEBRACE(t):
    r'\}'
    t.lexer.followsequals = 0
    return t

def t_AT(t):
    r'@'
    t.lexer.followsequals = 0
    return t
    
def t_SHARP(t):
    r'\#'
    t.lexer.followsequals = 0
    return t
    
def t_COMMA(t):
    r','
    t.lexer.followsequals = 0
    return t

def t_LBRACK(t):
    r'\['
    t.lexer.followsequals = 0
    return t

def t_RBRACK(t):
    r'\]'
    t.lexer.followsequals = 0
    return t

def t_NAME(t):
    r'[a-zA-Z_][-a-zA-Z:0-9/_]*'
    t.lexer.followsequals = 0
    return t

# Ignored characters
t_ignore = " \t"

def t_newline(t):
    r'\n+'
    t.lexer.lineno += t.value.count("\n")

def t_error(t):
    t.lexer.bib.error("%s:%d: syntax error at '%s'" % (lexer.file, t.lexer.lineno, t.value[0]))
    t.skip(1)
    
# Grammar

# Parsing rules
precedence = ( )

def p_stmt_singleton(t):
    'stmts : stmt'
    pass

def p_stmt_multiple(t):
    'stmts : stmt stmts'
    pass

def p_stmt_object(t):
    'stmt : object'
    t[0] = t[1]

def p_stmt_include(t):
    'stmt : ATINCLUDE NAME'
    filename = t[2]
    parsextxfile(filename, t.lexer.bib, t.lexer.seenfiles)

def p_stmt_preamble(t):
    'stmt : ATPREAMBLE OPENBRACE STRING CLOSEBRACE'
    t.lexer.bib.preambles += [t[3]]

def p_stmt_comment(t):
    'stmt : ATCOMMENT STRING'
    pass

def p_stmt_string(t):
    'stmt : ATSTRING OPENBRACE fields CLOSEBRACE'
    for key in t[3]:
	try:
	    t.lexer.bib.addobject('string', [key], [(None, {'name': t[3][key]})], t.lexer.file, t.lineno(3), t.lexer.bib.options)
	except Warning, detail:
	    t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
	except Exception, detail:
	    t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))

def p_object_defn(t):
    'object : AT NAME OPENBRACE keys COMMA fields conditionals CLOSEBRACE'
    t[2] = t[2].lower()
    try:
        t.lexer.bib.addobject(t[2], t[4], [(None, t[6])] + t[7], t.lexer.file, t.lineno(2), t.lexer.bib.options)
    except Warning, detail:
	t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(2), detail))
    except Exception, detail:
	t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(2), detail))

def p_object_error(t):
    'object : error CLOSEBRACE'
    pass

def p_keys_singleton(t):
    'keys : NAME'
    t[0] = [t[1]]

def p_keys_multiple(t):
    'keys : NAME EQUALS keys'
    t[0] = [t[1]] + t[3]

def p_conditionals_empty(t):
    'conditionals :'
    t[0] = []

def p_conditionals_singleton(t):
    'conditionals : conditional'
    t[0] = [t[1]]

def p_conditionals_multiple(t):
    'conditionals : conditional conditionals'
    t[0] = [t[1]] + t[2]

def p_conditional(t):
    'conditional : LBRACK fields RBRACK fields'
    t[0] = (t[2], t[4])

def p_fields_empty(t):
    'fields :'
    t[0] = []

def p_fields_singleton(t):
    'fields : field'
    t[0] = t[1]

def p_fields(t):
    'fields : field COMMA fields'
    t[0] = t[1]
    t[0].update(t[3])
              
def p_field(t):
    'field : NAME EQUALS value'
    t[1] = t[1].lower()
    if t[1] == 'author' or t[1] == 'editor':
	values = crosstexobjects.authorlist(t.lexer.bib.options)
	if isinstance(t[3], str):
	    for key in re.compile('\s+and\s+').split(t[3]):
		if key in t.lexer.bib:
		    values += [t.lexer.bib[key]]
		else:
		    try:
			t.lexer.bib.addobject('author', [key], [(None, {'name': key})], t.lexer.file, t.lineno(3), t.lexer.bib.options)
			values += [t.lexer.bib[key]]
		    except Warning, detail:
			t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
		    except Exception, detail:
			t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
	else:
	    values += [t[3]]
	t[0] = {t[1]: values}
    else:
	t[0] = {t[1]: t[3]}

def p_value_singleton(t):
    'value : simplevalue'
    t[0] = t[1]

def p_value_concat(t):
    'value : value SHARP simplevalue'
    t[0] = t[1].rstrip("\"") + t[3].lstrip("\"")

def p_simplevalue_number(t):
    'simplevalue : NUMBER'
    t[0] = t[1]
    
def p_simplevalue_name(t):
    'simplevalue : NAME'
    key = t[1]
    if key in t.lexer.bib:
	t[0] = t.lexer.bib[key]
    else:
	t.lexer.bib.error("%s:%d: undefined reference to object %s; using it as a string" % (t.lexer.file, t.lineno(1), key))
	t[0] = t[1]
    
def p_simplevalue_string(t):
    'simplevalue : STRING'
    t[0] = t[1]

def p_error(t):
    t.lexer.bib.error("%s:%d: parse error at '%s'" % (t.lexer.file, t.lexer.lineno, t.value[0]))
        
def parseauxfile(infilename, bib=bibliography()):
    if infilename[-4:] != ".aux":
        infilename += ".aux"
    if 'dump-files' in bib.options and bib.options['dump-files']:
        sys.stderr.write("Processing file %s...\n" % infilename)
    try:
        infile = open(infilename, 'r')
    except:
        bib.error("crosstex: file %s does not exist" % infilename)
        sys.exit(1)
    parseaux(infile, infilename, bib)
    infile.close()

# parses the AUX file and builds a list of citations
def parseaux(instream, infilename, bib):
    seenfiles = set()
    while 1:
        line = instream.readline()
        if not line:
            break
        if line[0:9] == "\\citation":
            citeline = line[10:].strip().rstrip("}")
            for cite in citeline.split(","):
                if cite.find(" ") >= 0:
                    bib.error("citation with empty space \"%s\"" % cite)
                    if bib.citations != []:
                        bib.error("    last good citation was", bib.citations[len(bib.citations)-1])
                cite = cite.strip(", 	")
                if cite == "":
                    bib.error("empty citation, check for spurious commas in \\cite{} commands")
                    if bib.citations != []:
                        bib.error("    last good citation was", bib.citations[len(bib.citations)-1])
		else:
		    bib.cite(cite)
        elif line[0:9] == "\\bibstyle":
	    for opt in line[10:].rstrip().rstrip("}").split(','):
		pos = opt.find('=')
		if pos > 0:
		    if opt[0:pos] == 'style':
			try:
			    style(opt[pos+1:], bib.options)
			except Exception, detail:
			    bib.error(detail)
		    else:
			bib.options[opt[0:pos]] = opt[pos+1:]
		else:
		    try:
			style(opt, bib.options)
		    except:
			bib.options[opt] = True
        elif line[0:8] == "\\bibdata":
            fnamesfull = line[9:].rstrip().rstrip("}")
            fnames = fnamesfull.split(",")
            for fname in fnames:
                parsextxfile(fname, bib, seenfiles)
            
def pathopen(name, mode, bib):
    if name[0] == "/":
        if 'dump-files' in bib.options and bib.options['dump-files']:
            sys.stderr.write("Processing %s...\n" % name)
        return open(name, mode)

    # filename is relative, try all elements of the path
    for path in bib.options["path"].split(":"):
        try:
             file = open(path + "/" + name, mode)
             if 'dump-files' in bib.options and bib.options['dump-files']:
                 sys.stderr.write("Processing %s...\n" % (path + "/" + name))
             return file
        except:
             pass
    raise IOError, 'File not found'
    
def parsextxfile(infilename, bib=bibliography(), seenfiles=set()):
    suffixes = [".xtx", ".bib"]
    if 'dump-files' in bib.options and bib.options['dump-files']:
        sys.stderr.write("Processing file %s...\n" % infilename)
    if infilename in seenfiles:
	if 'dump-files' in bib.options and bib.options['dump-files']:
            sys.stderr.write("File %s already processed, skipping.\n" % infilename)
	return
    for suffix in suffixes:
        if not infilename.endswith(suffix):
            filename = infilename + suffix
        else:
            filename = infilename
        try:
            infile = pathopen(filename, 'r', bib)
            # we get here only if we succeed
	    seenfiles.add(infilename)
	    parsextx(infile, filename, bib, seenfiles)
            infile.close()
	    return
        except IOError:
	    pass
    else:
        bib.error("Bibliography database %s not found, skipping" % infilename)
        return
    
# parses the XTX file and builds an object hierarchy
def parsextx(instream, infilename, bib, seenfiles):
    # Build the lexer and initialize the parser
    global topdir
    lexer = lex.lex()
    lexer.bib = bib
    lexer.file = infilename
    lexer.lineno = 1
    lexer.seenfiles = seenfiles
    lexer.followsequals = 0
    #parser = yacc.yacc(debug=1, write_tables=1)
    parser = yacc.yacc(debug=0, write_tables=0)
    parser.parse(instream.read(), lexer=lexer)

def style(style, options):
    global styles
    if style not in styles:
	raise Warning, "unkown bibliography style %s" % style
    options.update(styles[style])

def usage():
    print "crosstex [options] filename"
    print ""
    print " General Options"
    print "  --path /path1:/path2:\tuse path to look for files (default=.:%s)" % topdir
    print ""
    print " Options for reference appearance in the bibliography:"
    print "  --use-short-authornames:\tShorten first names in bib entries to just initials"
    print "  --use-short-conferencenames:\tuse short conference names"
    print "  --use-short-monthnames:\tuse three/four letter short month prefix"
    print "  --use-short-statenames:\tuse use two letter abbreviation for state"
    print "  --use-short-countrynames:\tuse short country name where possible"
    print "  --use-short-journalnames:\tuse short journal name where possible"
    print "  --add-proceedingsof:\t\tadd \"Proceedings of the\" for conf and workshop publications"
    print "  --add-procof:\t\t\tadd \"Proc. of\" for conf and workshop publications"
    print "  --use-inforarticles:\t\tadd \"In\" for articles"
    print "  --title-lowercase:\t\tmake titles all lowercase"
    print "  --title-uppercase:\t\tmake titles all uppercase"
    print "  --title-titlecase:\t\tmake titles in titlecase"
    print "  --break-lines:\t\tInsert line breaks between author, title, and publication information"
    print "  --blank-labels:\t\tShow no labels in the bibliography (for generating standalone bibliographies)"
    print "  --links none:\t\t\tDo not use hyperlinks (default)"
    print "  --links default:\t\tInclude hyperlinks found in a common set of fields"
    print "  --links field,field,...:\tInclude hyperlinks if found in the specified fields"
    print "  --title-head:\t\t\tMake the title come before the authors and bold"
    print "  --sort field,-field,...:\tSort entries based on specified fields (default=label,author,year,month)"
    print "  --sort none:\t\t\tLeave entries in citation order"
    print "  --cite key:\t\t\tCite the specified key"
    print "  --cite *:\t\t\tCite all entries (may require shell escape)"
    print ""
    print " Options for citation style:"
    print "  --style name:\t\t\tOverride with named style, e.g. plain, unsrt, abbrv, full, alpha"
    print "  --cite-by number:\t\tRefer to papers by numbers, e.g. [1] (default)"
    print "  --cite-by initials:\t\tRefer to papers by concatenation of lastname initials, e.g. [SBRD04b]"
    print "  --cite-by fullname:\t\tRefer to papers by last names, e.g. [Sirer et al. 04]"
    print ""
    print " Sanity checking of the object database:"
    print "  --quiet:\t\t\tdo not sanity check the input"
    print "  --strict:\t\t\tapply stricter checks"
    print ""
    print " Debugging:"
    print "  --dump-locations:\t\tdump the location data for debugging"
    print "  --dump-conferences:\t\tdump the conference data for debugging"
    print "  --dump-workshops:\t\tdump the workshop data for debugging"
    print "  --dump-files:\t\t\tdump the input files processed"
    print ""
    print " Conversion:"
    print "  --xtx2bib:\t\t\tconvert to plain BibTeX on standard output"
    print "  --xtx2html:\t\t\tconvert to html with HeVeA"
    print ""
    print " Options override defaults from .aux files"
    print " De-activate a boolean option with e.g. --no-option-name"
    sys.exit(1)

if int(len(sys.argv) == 0):
    usage()

options = {}

# The symlink from "xtx2bib" to this file turns on the xtx2bib option.
args = [ '--' + sys.argv[0].split("/")[-1] ] + sys.argv[1:]

# Parse arguments.
nopt = 0
for opt in args:
    if opt == "--help":
        usage()
    elif opt == "--path" or opt == "--cite-by":
        if len(args) <= nopt+1:
            usage()
        else:
            options[opt[2:]] = args[nopt+1]
            nopt += 2
    elif opt == "--cite":
        if len(args) <= nopt+1:
            usage()
	if 'cite' not in options:
	    options['cite'] = ''
	if options['cite'] != '':
	    options['cite'] += ','
        options[opt[2:]] += args[nopt+1]
        nopt += 2
    elif opt == "--sort":
        if len(args) <= nopt+1:
            usage()
	if args[nopt+1] != 'none':
            options[opt[2:]] = args[nopt+1]
        nopt += 2
    elif opt == "--links":
        if len(args) <= nopt+1:
            usage()
	if args[nopt+1] == 'default':
            options[opt[2:]] = styles['html']['links']
            nopt += 2
        else:
            options[opt[2:]] = args[nopt+1]
            nopt += 2
    elif opt == "--style":
        if len(args) <= nopt+1:
            usage()
        else:
	    try:
	        style(args[nopt+1], options)
	    except Exception, detail:
		sys.stderr.write("crosstex: %s\n" % detail)
            nopt += 2
    elif len(opt) >= 5 and opt[0] == "-" and opt[1] == "-" and opt[2] == "n" and opt[3] == "o" and opt[4] == "-":
        options[opt[5:]] = False
        nopt += 1
    elif len(opt) >= 2 and opt[0] == "-" and opt[1] == "-":
        options[opt[2:]] = True
        nopt += 1
	if opt[2:] == 'xtx2html':
	    try:
	        style('xtx2html', options)
	    except:
		pass

if nopt >= len(args):
  usage()

if 'path' not in options:
    options['path'] = ".:%s" % topdir

if 'sort' not in options:
    options['sort'] = 'label,author,year,month'

for infilename in args[nopt:]:
    # Use a difference environment for each file.
    bib = bibliography()
    bib.options.update(options)

    # Parse the file.
    outfile = sys.stdout
    if infilename[-4:] == ".xtx" or infilename[-4:] == ".bib":
        parsextxfile(infilename, bib)
	if 'xtx2html' in bib.options and bib.options['xtx2html']:
	    t = pipes.Template()
	    t.append('hevea -O', '--')
	    if infilename.endswith('.xtx') or infilename.endswith('.bib'):
	        outfile = t.open(infilename[:-4] + '.html', 'w')
	    else:
	        outfile = t.open(infilename + '.html', 'w')
    else:
        parseauxfile(infilename, bib)
	if infilename.endswith('.aux'):
	    outfile = open(infilename[:-4] + '.bbl', 'w')
	else:
	    outfile = open(infilename + '.bbl', 'w')

    # Ensure command-line arguments overwrite options in any .aux files.
    bib.options.update(options)
    if 'cite' in bib.options:
        for citation in bib.options['cite'].split(','):
	    bib.cite(citation)

    # Handle dump-locations, dump-conferences, etc.
    for option in bib.options:
	if option.startswith('dump-') and option[5:-1] in dir(crosstexobjects) and bib.options[option]:
	    dumpclass = option[5:-1].lower()
	    sys.stderr.write("%s\n" % (option[5:].upper() + ':'))
	    for key in bib.primarykeys:
		if bib[key]._name == dumpclass:
		    sys.stderr.write("%s\t%s\n" % (key, bib[key]))

    if len(bib.citations) == 0 and (('xtx2bib' in bib.options and bib.options['xtx2bib']) or ('xtx2html' in bib.options and bib.options['xtx2html'])):
	bib.cite('*')

    # Prepare the citation list.
    bib.sortcitations()

    # Print headers required by output format.
    if 'xtx2bib' in bib.options and bib.options['xtx2bib']:
	for i in bib.preambles:
	    outfile.write("@PREAMBLE { \"" + i + "\" }\n\n")
    else:
	if 'xtx2html' in bib.options and bib.options['xtx2html']:
	    outfile.write("\\documentclass{report}\n")
	    outfile.write("\\usepackage{hyperref}\n")
	    outfile.write("\\begin{document}\n")
	for i in bib.preambles:
	    outfile.write(i)
	    outfile.write("\n")
	maxstr = ''
	for key in bib.citations:
	    citekey = bib[key]._label().replace("{\\etalchar{+}}", "X")
	    if len(citekey) > len(maxstr):
		maxstr = citekey
	if len(bib.citations) != 0:
	    strlen = int(math.ceil(math.log(len(bib.citations), 10)))
	    if maxstr == "" and ('blank-labels' not in bib.options or not bib.options['blank-labels']):
		maxstr = "00000000000"[0:strlen]
	    elif len(maxstr) >= 13:
                maxstr = "XXXXXXXXXXXXX"
	else:
	    maxstr = "X"
	if 'blank-labels' in bib.options and bib.options['blank-labels']:
	    outfile.write("\\makeatletter\\def\\@biblabel#1{}\\makeatother\n")
        if 'break-lines' in bib.options and bib.options['break-lines']:
	    outfile.write("\\renewcommand{\\newblock}{\\\\}")
	outfile.write("\\newcommand{\\etalchar}[1]{$^{#1}$}\n")
	outfile.write("\\begin{thebibliography}{" + maxstr + "}\n")

    # Format each cited work.
    for key in bib.citations:
	outfile.write(str(bib[key]))

    # Print footers required by output format.
    if 'xtx2bib' in bib.options and bib.options['xtx2bib']:
	pass
    else:
        outfile.write("\\end{thebibliography}\n")
	if 'xtx2html' in bib.options and bib.options['xtx2html']:
	    outfile.write("\\end{document}\n")
    outfile.close()
